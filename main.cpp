/* Теоретическая вставка (Что смогла, то перевела)
* 
									Контейнер std::vector:

1. Предварительно выделяется пространство для будущих элементов, поэтому выделяется дополнительное
	пространство сверх того, что необходимо для начальных элементов.
2. Для каждого элемента требуется пространство только для типа элемента (без дополнительных 
	указателей).
3. Можно перераспределять память для всего вектора в любой момент, когда вы добавляете элемент.
4. Вставки в конце требуют постоянного времени, но вставки в другом месте требуют больших затрат.
5. Удаления в конце вектора зависят от постоянного времени, но в остальном это O(n).
6. Вы можете случайным образом обращаться к его элементам.
7. Итераторы становятся недействительными, если вы добавляете или удаляете элементы в вектор или 
	из него.
8. Вы можете легко получить доступ к базовому массиву, если вам нужен массив элементов.

									Контейнер std::list:

1. Нет предварительно выделенной памяти. Затраты памяти на сам список постоянны.
2. Каждый элемент требует дополнительного пространства для узла, который содержит элемент, включая
	указатели на следующий и предыдущий элементы в списке.
3. Никогда не нужно перераспределять память для всего списка только потому, что вы добавляете элемент.
4. Вставки и удаления обходятся быстро, независимо от того, в каком месте списка они происходят.
5. Объединение списков происходит быстро по времени.
6. Вы не можете получать случайный доступ к элементам, поэтому доступ к определенному элементу в 
	списке может быть времязатратным.
7. Итераторы остаются действительными, даже когда вы добавляете или удаляете элементы из списка.
8. Если вам нужен массив элементов, вам придется создать новый и добавить их все в него, поскольку
	базового массива нет.
*/

#include <iostream>
#include <vector>
#include <list>
#include <stdlib.h>     /* srand, rand */
#include <time.h>       /* time */
#include <chrono> //для измерения времени
#include <iterator> //для std::advance

using namespace std;

int main() {

	int n = 1000; //столько элементов вставляем и удаляем 

	//создаём вектор
	vector<int> vec(n);

	//создаём список
	list<int> lis;

	//заполняем вектор и список рандомными значениями 
	srand(time(NULL));

	for (int i = 0; i < n; i++) {
		vec[i] = rand() % 101; //от 0 до 100
		lis.push_back(rand() % 101);
	}

	//задание 1. проанализировать объём занимаемой памяти для вектора и списка 

	cout << "Ex.1" << endl << endl;

	//объём памяти, который занимает каждый контейнер
	cout << "Memory capacity for vector: " << sizeof(vec) << " bytes" << endl;
	cout << "Memory capacity for list: " << sizeof(lis) << " bytes" << endl << endl;

	cout << "Conclusion" << endl << endl;

	if (sizeof(vec) < sizeof(lis)) {
		cout << "A vector takes up less memory than a list" << endl;
	} else if(sizeof(vec) > sizeof(lis)) {
		cout << "A list takes up less memory than a vector" << endl;
	} else {
		cout << "A vector takes up the same amount of memory as a list" << endl;
	}

	//задание 2. демонстрация более быстрой работы списка по сравнению с вектором

	cout << endl << "Ex. 2" << endl << endl;

	//2.1. работа с вектором
	
	//начало замера времени для вектора
	auto begin = chrono::steady_clock::now();

	//будем вставлять элемент в середину вектора 
	for (int i = 0; i < n; i++) {
		vec.insert(vec.begin() + vec.size() / 2, 2); //например, вставим двойку
	}

	//а теперь удалять элементы из середины вектора
	for (int i = 0; i < n; i++) {
		vec.erase(vec.begin() + vec.size() / 2); 
	}

	//конец замера времени для вектора
	auto end = chrono::steady_clock::now();

	auto time = chrono::duration_cast<chrono::milliseconds>(end - begin); //преобразует объект типа <code>time_point во временной интервал

	//измеряем в миллисекундах
	cout << "The time for working vector is: " << time.count() << " ms" << endl;

	//2.2. работа с листом

	//начало замера времени для листа
	begin = chrono::steady_clock::now();

	//будем вставлять элемент в середину листа
	for (int i = 0; i < n; i++) {
		auto it = lis.begin();
		advance(it, lis.size() / 2); //*
		lis.insert(it, 2); 
	}

	/* - Функция advance() перемещает итератор, передаваемый ей в качестве аргумента. При этом
	смещение может производиться в прямом (или обратном) направлении сразу на несколько элементов */

	//а теперь удалять элементы из середины листа 
	for (int i = 0; i < n; i++) {
		auto it = lis.begin();
		advance(it, lis.size() / 2); //*
		lis.insert(it, 2);
		lis.erase(it);
	}

	//конец замера времени для листа
	end = chrono::steady_clock::now();

	time = chrono::duration_cast<chrono::milliseconds>(end - begin); //преобразует объект типа <code>time_point во временной интервал

	//измеряем в миллисекундах
	cout << "The time for working list is: " << time.count() << " ms" << endl;

	return 0;
}